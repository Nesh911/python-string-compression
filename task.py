# Нашел способ упростить решение
# брал первый элемент и сравнивал со следующим, если они одинаковы добавлял к счетчику +1, затем брал второй и так далее
# если появлялся новый элемент обнулял счетчик
s = "AADQSSQQWSSDDDFFFGHJ"
c = 1
x = 1
j = s[x:x+1]
t = ""
for i in s:
    if i in j:
        c += 1
    else:
        t += i
        if c != 1:
            t += str(c)
        c = 1
    x += 1
    j = s[x:x+1]
print(t)
# В данном примере получаем "A2DQS2Q2WS2D3F3GHJ"

# Первый вариант который я пытался сделать при беседе.

d = {}
t = ""
x = 1
f = s[x:x+1]
# Получаю словарь с элементами и количествоим их повторений
for c in s:
    if c in d:
        d[c] += 1
    else:
        d[c] = 1

# Форматирую все в строку и если элемент встречается всего один раз, вывожу только ключ
for k in d.keys():
    if d[k] != 1:
        t += "%s%d" % (k, d[k])
    else:
        t += k
print(t)
# В данном примере получаем "A3Q3WS2D3F3GHJ"


# Изначально просто добавил replase чтобы убрать "1"
# но как оказалось все ломается если в строке будут цыфры
# print("".join("%s%s" % (i, s.count(i)) for i in (set(s))).replace("1",""))


# с подобных конструкций я начал знакомство с питоном, так как или мыли заполнены тесты по которым я начал учиться.
# привык иногда использовать, не всегда понимая как устроенны внутри.


